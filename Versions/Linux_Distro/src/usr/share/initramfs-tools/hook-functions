# -*- shell-script -*-
# shellcheck shell=sh

catenate_cpiogz() {
	# Sanity check
	if [ ! -e "${1}" ]; then
		echo "W: catenate_cpiogz: arg1='${1}' does not exist." >&2
		return
	fi

	cat "${1}" >>"${__TMPCPIOGZ}"
}

prepend_earlyinitramfs() {
	# Sanity check
	if [ ! -e "${1}" ]; then
		echo "W: prepend_earlyinitramfs: arg1='${1}' does not exist." >&2
		return
	fi

	cat "${1}" >>"${__TMPEARLYCPIO}"
}

# force_load module [args...]
force_load()
{
	manual_add_modules "$1"
	echo "${@}" >>"${DESTDIR}/conf/modules"
}

# Takes a file containing a list of modules to be added as an
# argument, figures out dependencies, and adds them.
#
# Input file syntax:
#
#   # comment
#   modprobe_module_name [args ...]
#   [...]
#
add_modules_from_file()
{
	# Sanity check
	if [ ! -e "${1}" ]; then
		echo "W: add_modules_from_file: arg1='${1}' does not exist." >&2
		return
	fi

	grep '^[^#]' "${1}" | while read -r module args; do
		[ -n "$module" ] || continue
		force_load "${module}" "${args}"
	done
}

# Locate a firmware file with the given name and copy it into DESTDIR, unless
# DESTDIR already contains such a file.
# Returns an error if no such firmware file can be located and DESTDIR doesn't
# already contain any matching file. (It is up to the caller to figure out
# whether a warning should be printed in that case.)
add_firmware()
{
	local firmware found_fwloc fwloc fw_path_para path suffix

	firmware="${1}"

	if [ -e /sys/module/firmware_class/parameters/path ]; then
		read -r fw_path_para < /sys/module/firmware_class/parameters/path
	fi

	for suffix in "" ".zst" ".xz"; do
		for path in ${fw_path_para:+"$fw_path_para"} \
			"/lib/firmware/updates/${version?}" \
			"/lib/firmware/updates" \
			"/lib/firmware/${version}" \
			"/lib/firmware"; do
			fwloc="${path}/${firmware}${suffix}"
			if [ -e "${DESTDIR}${fwloc}" ]; then
				# DESTDIR already contains a matching firmware file.
				return 0
			fi
			if [ -z "${found_fwloc}" ] && [ -e "${fwloc}" ]; then
				found_fwloc="$fwloc"
			fi
		done
	done

	if [ -z "${found_fwloc}" ]; then
		# We can't figure out where to get that firmware from.
		return 1
	fi

	copy_file firmware "${found_fwloc}"
}

# Add dependent modules + eventual firmware
# This function was changed to only collect the wanted kernel modules.
# Call apply_add_modules to copy the kernel modules.
manual_add_modules()
{
	for module in "$@"; do
		echo "$module" >> "$__MODULES_TO_ADD"
	done
}

# Copy the kernel modules that were marked in manual_add_modules
apply_add_modules()
{
	# shellcheck disable=SC2046
	_call_dracut_install $(sort -u "$__MODULES_TO_ADD") || return $?
	true > "$__MODULES_TO_ADD"
}

_call_dracut_install()
{
	local dracut_verbose fw_path_para

	if [ $# -eq 0 ]; then
		return
	fi

	if [ "${verbose?}" = "y" ]; then
		dracut_verbose=-v
	fi

	if [ -e /sys/module/firmware_class/parameters/path ]; then
		read -r fw_path_para < /sys/module/firmware_class/parameters/path
	fi
	/usr/lib/dracut/dracut-install -D "$DESTDIR" --kerneldir "/lib/modules/${version?}" \
		--firmwaredirs "${fw_path_para:+${fw_path_para}:}/lib/firmware/updates/${version?}:/lib/firmware/updates:/lib/firmware/${version?}:/lib/firmware" \
		${dracut_verbose-} -o -m "$@"
}

# manual_add_modules() takes care of adding firmware for things that were built
# as modules; but drivers can also be built into the kernel itself. To cover
# that case, we have to look at modules.builtin.modinfo instead.
# This file is generated by the kernel's build process since commit 898490c010b5
# ("moduleparam: Save information about built-in modules in separate file"),
# which was added in Linux 5.2.
add_builtin_firmware()
{
	local builtin_modinfo_path builtin_modname firmware

	builtin_modinfo_path="/lib/modules/${version?}/modules.builtin.modinfo"
	if [ ! -e "$builtin_modinfo_path" ]; then
		if linux-version compare "${version}" ge 5.2; then
			echo "W: Can't find modules.builtin.modinfo (for locating built-in drivers' firmware, supported in Linux >=5.2)" >&2
		fi
		return
	fi

	tr '\0' '\n' < "$builtin_modinfo_path" | grep -E '^[^=]*\.firmware=' | sed -n 's/\.firmware=/\t/p' | while read -r builtin_modname firmware; do
		if ! add_firmware "$firmware"; then
			echo "W: Possible missing firmware /lib/firmware/${firmware} for built-in driver ${builtin_modname}" >&2
		fi
	done
}

# Copy a file to the initramfs:
# $1 = file type, for debug logging
# $2 = source file name
# $3 (optional) = target file or directory name in the initramfs
#
# * If the target is not specified, it defaults to the source file
#   name.
# * If the target is specified and exists as a directory under
#   $DESTDIR or ends in a slash, the basename of the source is
#   appended to it.
#
# The target file's containing directories are created if necessary.
#
# If the source file name includes a symlink, other than usr-merge
# symlinks, and the canonical name of the source is not the same as
# the target, the source file is copied to its canonical name in the
# initramfs and the target is created as a symlink.
#
# Returns:
# * If the file was copied successfully, 0
# * If the target file already existed, 1
# * On error, >1
copy_file() {
	local type src target link_target

	type="${1}"
	src="${2}"
	target="${3:-$2}"

	[ -f "${src}" ] || return 2

	if [ -d "${DESTDIR}/${target}" ] || [ "${target%/}" != "$target" ]; then
		target="${target}/${src##*/}"
	fi

	# Canonicalise target to be absolute, so the comparisons below
	# will work
	target="$(realpath -ms "/${target}")" || return 2

	# Canonicalise usr-merged directories
	case "${src}" in
	/bin/* | /lib* | /sbin/*)
		[ "$(readlink -f /bin)" = /usr/bin ] && src="/usr${src}"
		;;
	esac
	case "${target}" in
	/bin/* | /lib* | /sbin/*) target="/usr${target}" ;;
	esac

	# check if already copied
	[ -e "${DESTDIR}/${target}" ] && return 1

	mkdir -p "${DESTDIR}/${target%/*}"

	# Check whether source or one of its ancestors is a symlink.
	# If so, copy the symlink target and make the target a symlink
	# too.  We don't need to replicate a chain of links completely;
	# just link directly to the ultimate target.
	link_target="$(readlink -f "${src}")" || return $(($? + 1))
	if [ "${link_target}" != "$(realpath -s "$src")" ]; then
		# Update source for the copy
		src="${link_target}"

		# Canonicalise usr-merged target directories
		case "${link_target}" in
		/bin/* | /lib* | /sbin/*) link_target="/usr${link_target}" ;;
		esac

		if [ "${link_target}" != "${target}" ]; then
			[ "${verbose?}" = "y" ] && echo "Adding ${type}-link ${target}"

			# Create a relative link so it always points
			# to the right place
			ln -rs "${DESTDIR}/${link_target}" "${DESTDIR}/${target}"
		fi

		# Copy the link target if it doesn't already exist
		target="${link_target}"
		[ -e "${DESTDIR}/${target}" ] && return 0
		mkdir -p "${DESTDIR}/${target%/*}"
	fi

	[ "${verbose}" = "y" ] && echo "Adding ${type} ${src}"

	cp -pP "${src}" "${DESTDIR}/${target}" || return $(($? + 1))
}

# Copy an executable or shared library to the initramfs:
# $1 = source file name
# $2 (optional) = target file or directory name in the initramfs
#
# The source and all its shared library dependencies are copied
# using copy_file.
#
# Returns:
# * If the files were copied successfully or already exited, 0
# * On error, >0
copy_exec() {
	local src target x nonoptlib ret

	src="${1}"
	target="${2:-$1}"

	copy_file binary "${src}" "${target}" || return $(($? - 1))

	# Copy the dependant libraries
	for x in $(env --unset=LD_PRELOAD ldd "${src}" 2>/dev/null | sed -e '
		/^[^\t]/d;
		/\//!d;
		/linux-gate/d;
		/=>/ {s/.*=>[[:blank:]]*\([^[:blank:]]*\).*/\1/};
		s/[[:blank:]]*\([^[:blank:]]*\) (.*)/\1/' 2>/dev/null); do

		# Try to use non-optimised libraries where possible.
		# We assume that all HWCAP libraries will be in tls,
		# sse2, vfp or neon.
		nonoptlib=$(echo "${x}" | sed -e 's#/lib/\([^/]*/\)\?\(tls\|i686\|sse2\|neon\|vfp\).*/\(lib.*\)#/lib/\1\3#')
		nonoptlib=$(echo "${nonoptlib}" | sed -e 's#-linux-gnu/\(tls\|i686\|sse2\|neon\|vfp\).*/\(lib.*\)#-linux-gnu/\2#')

		if [ -e "${nonoptlib}" ]; then
			x="${nonoptlib}"
		fi

		# Handle common dlopen() dependency (Debian bug #950254)
		case "${x}" in
		*/libpthread.so.*)
			copy_libgcc || return
			;;
		esac

		copy_file binary "${x}" || {
			ret=$?
			[ ${ret} = 1 ] || return $((ret - 1))
		}
	done
}

# Copy libgcc_s.so for the running architecture to the initramfs.
# This function takes no parameter.
#
# Returns:
# * If the library was copied successfully or already existed, 0
# * On error, >0
copy_libgcc() {
	local libdir library

	for libdir in $(ld.so --list-diagnostics | sed -n 's/^path.system_dirs.*="\(.*\)"$/\1/p'); do
		for library in "${libdir}"/libgcc_s.so.[1-9]; do
			[ -e "$library" ] || continue
			copy_exec "${library}" || return
		done
	done
}

# Copy entire subtrees to the initramfs
copy_modules_dir()
{
	local kmod first exclude
	local modules=
	local dir="$1"
	shift

	if ! [ -d "${MODULESDIR}/${dir}" ]; then
		return;
	fi
	if [ "${verbose}" = "y" ]; then
		echo "Copying module directory ${dir}"
		if [ $# -ge 1 ]; then
			echo "(excluding $*)"
		fi
	fi

	# Build up an expression for find
	first=true
	for exclude in "$@"; do
		# Change .ko suffix in exclusion to .ko*
		if [ "${exclude%.ko}" != "${exclude}" ]; then
			exclude="${exclude}*"
		fi
		$first && set --
		set -- "$@" -name "${exclude}" -prune -o
		first=false
	done

	# shellcheck disable=SC2044
	for kmod in $(find "${MODULESDIR}/${dir}" "$@" -name '*.ko*' -printf '%f\n'); do
		modules="$modules ${kmod%%.*}"
	done
	# shellcheck disable=SC2086
	manual_add_modules $modules
}

# walk /sys for relevant modules
sys_walk_mod_add()
{
	local driver_path module device_path modalias devlink

	# This is a crude way of storing two stacks in "$@" by using
	# "--" as a separator between them, to implement iterative
	# graph traversal over parent/supplier dependencies. The first
	# part is device paths to traverse, the other is visited ones.
	set -- "$1" "--"
	while [ "$1" != "--" ]; do
		device_path="$(readlink -f "$1")"
		shift

		# Don't walk into same path twice, avoid infinite recursion
		case "$*" in
			"${device_path}")     continue ;;
			"${device_path} "*)   continue ;;
			*" ${device_path} "*) continue ;;
			*" ${device_path}")   continue ;;
		esac

		if [ "$device_path" = "/sys" ]; then
			continue
		fi

		# Keep current path to add module/modalias for
		set -- "$@" "$device_path"

		# Walk into suppliers in next iteration
		for devlink in "${device_path}/supplier:"*; do
			if [ -d "$devlink" ]; then
				set -- "${devlink}/supplier/" "$@"
			fi
		done

		# Walk into parent in next iteration
		set -- "$(dirname "$device_path")" "$@"
	done
	shift

	for device_path in "$@"; do
		# device modalias
		if [ -e "${device_path}/modalias" ]; then
			modalias=$(cat "${device_path}/modalias")
			if [ -n "${modalias}" ]; then
				manual_add_modules "${modalias}"
			fi
		fi

		# current driver module
		driver_path="$(readlink -f "${device_path}/driver/module")"
		if [ -e "$driver_path" ]; then
			module="$(basename "$(readlink -f "$driver_path")")"
			if [ -n "${module}" ]; then
				manual_add_modules "${module}"
			fi
		fi
	done
}

block_dev_sys_walk_mod_add()
{
	local dev_sys_path disk_sys_path component

	# Resolve symlink so sys_walk_mod_add can walk up the hierarchy
	dev_sys_path="$(readlink -f "$1")"

	# Find whole disk from partition
	if grep -q "^DEVTYPE=partition$" "$dev_sys_path/uevent"; then
		disk_sys_path="$dev_sys_path/.."
	else
		disk_sys_path="$dev_sys_path"
	fi

	# Iterate over component of a layered device
	find "$disk_sys_path/slaves" -mindepth 1 -maxdepth 1 | while read -r component; do
		block_dev_sys_walk_mod_add "$component"
	done

	sys_walk_mod_add "${dev_sys_path}"
}

block_dev_mod_add()
{
	local dev_node dev_num dev_sys_path
	dev_node="$1"

	# Look up device number and convert to decimal as it appears in sysfs
	dev_num="$(stat -L -c %t:%T "$dev_node")"
	dev_num="$((0x${dev_num%:*})):$((0x${dev_num#*:}))"

	# Look up device in sysfs
	dev_sys_path="/sys/dev/block/$dev_num"
	if [ ! -d "$dev_sys_path" ]; then
		echo "mkinitramfs: for device ${dev_node} missing ${dev_sys_path}" >&2
		echo "mkinitramfs: workaround is MODULES=most" >&2
		echo "mkinitramfs: Error please report the bug" >&2
		exit 1
	fi

	block_dev_sys_walk_mod_add "$dev_sys_path"
}

# Copy all loaded or built-in modules matching the given pattern.
# Pattern mustn't include directory or '.ko' suffix but should use
# '[-_]' to allow for differences in naming between /sys/module and
# modules.builtin.
add_loaded_modules()
{
	local pattern="$1"
	local module device builtin
	builtin="/lib/modules/$(uname -r)/modules.builtin"

	for module in /sys/module/$pattern; do
		if [ -d "$module" ]; then
			manual_add_modules "$(basename "$module")"
		fi
	done
	# shellcheck disable=SC2231
	for device in /sys/module/$pattern/drivers/*/*; do
		if [ -d "$device" ] && [ "$(basename "$device")" != "module" ]; then
			sys_walk_mod_add "$device"
		fi
	done
	if [ -f "$builtin" ]; then
		while read -r module; do
			case "$module" in
			*/$pattern.ko)
				manual_add_modules "$(basename "$module" .ko)"
				;;
			esac
		done < "$builtin"
	fi
}

# find and only copy modules relevant to a mountpoint
dep_add_modules_mount()
{
	local dir dev_node FSTYPE

	dir="$1"

	# require mounted sysfs
	if [ ! -d /sys/devices/ ]; then
		echo "mkinitramfs: MODULES dep requires mounted sysfs on /sys" >&2
		exit 1
	fi

	# find out block device + fstype
	# shellcheck disable=SC2034
	eval "$(while read -r dev mp fs opts rest ; do \
		[ "$mp" = "$dir" ] && [ "$fs" != "rootfs" ] \
		&& printf "dev_node=%s\\nFSTYPE=%s" "$dev" "$fs"\
		&& break; done < /proc/mounts)"

	# Only the root mountpoint has to exist; do nothing if any other
	# directory is not a mountpoint.
	if [ "$dir" != / ] && [ -z "$dev_node" ]; then
		return
	fi

	# handle ubifs and return since ubifs is mounted on char devices
	# but most of the commands below only work with block devices.
	if [ "${FSTYPE}" = "ubifs" ]; then
		manual_add_modules "${FSTYPE}"
		return
	fi

	# Return upon finding a zfs because when used as rootfs it is
	# not presented as a typical mount point like other fs, so that
	# can not be handled with commands below. Since zfs has its own
	# addons in the zfs-initramfs package, do nothing here.
	if [ "${FSTYPE}" = "zfs" ]; then
		return
	fi

	if [ "$dir" = / ] && [ "${dev_node}" = "/dev/root" ] ; then
		if [ -b "${dev_node}" ]; then
			# Match it to the canonical device name by UUID
			dev_node="/dev/disk/by-uuid/"$(blkid -o value -s UUID "${dev_node}") 2>/dev/null
		else
			# Does not exist in our namespace, so look at the
			# kernel command line
			dev_node=
			# shellcheck disable=SC2013
			for arg in $(cat /proc/cmdline); do
				case "$arg" in
				root=*)
					dev_node="${arg#root=}"
					if [ "${dev_node#/dev/}" = "$dev_node" ]; then
						dev_node="/dev/$dev_node"
					fi
					;;
				--)
					break
					;;
				*)
					;;
				esac
			done
		fi
	fi

	# recheck device
	if [ -z "$dev_node" ] || ! dev_node="$(readlink -f "${dev_node}")" \
		|| ! [ -b "$dev_node" ]; then
		echo "mkinitramfs: failed to determine device for $dir" >&2
		echo "mkinitramfs: workaround is MODULES=most, check:" >&2
		echo "grep -r MODULES ${CONFDIR}" >&2
		echo "" >&2
		echo "Error please report bug on initramfs-tools" >&2
		echo "Include the output of 'mount' and 'cat /proc/mounts'" >&2
		exit 1
	fi

	# do not trust mount, check superblock
	eval "$(/usr/lib/klibc/bin/fstype "${dev_node}")"

	# check that fstype fs recognition
	if [ "${FSTYPE}" = "unknown" ]; then
		FSTYPE=$(blkid -o value -s TYPE "${dev_node}")
		if [  -z "${FSTYPE}" ]; then
			echo "mkinitramfs: unknown fstype on device ${dev_node}" >&2
			echo "mkinitramfs: workaround is MODULES=most" >&2
			echo "Error please report bug on initramfs-tools" >&2
			exit 1
		fi
	fi

	# Add filesystem
	manual_add_modules "${FSTYPE}"

	block_dev_mod_add "$dev_node"
}

class_add_modules()
{
	local device

	for device in "/sys/class/$1"/*; do
		device="$(readlink -f "$device")" \
			&& sys_walk_mod_add "$device"
	done
}

dep_add_modules()
{
	local device dev_node
	local modules=

	dep_add_modules_mount /
	dep_add_modules_mount /usr

	if [ -n "${RESUME}" ]; then
		dev_node="$(resolve_device "${RESUME}")"
		if [ -n "${dev_node}" ]; then
			block_dev_mod_add "${dev_node}"
		fi
	fi

	# sys walk some important device classes
	for class in extcon gpio phy pwm regulator rtc; do
		class_add_modules "$class"
	done

	# clk, USB-PHY, pinctrl and reset devices are outside the device
	# model (!) so match loaded modules by name
	add_loaded_modules 'clk[-_]*'
	add_loaded_modules 'phy[-_]*'
	add_loaded_modules 'pinctrl[-_]*'
	add_loaded_modules 'reset[-_]*'

	# Sys walk keyboards.  We identify keyboards as input devices
	# that can generate at least key events 1-31; udev has the
	# same heuristic.  Note that the format of the bitmap
	# properties depends on the word size of the process reading
	# the uevent file!
	for device in /sys/class/input/input*; do
		if grep -qs "^KEY=.*fffffff[ef]$" "${device}/uevent"; then
			sys_walk_mod_add "$(readlink -f "$device")"
		fi
	done

	# Sys walk graphics for machines that don't have a generic framebuffer
	# device and wouldn't have a working video console otherwise.
	walk_graphics=yes
	for device in /sys/bus/platform/drivers/efi-framebuffer/* \
	              /sys/bus/platform/drivers/platform-framebuffer/* \
	              /sys/bus/platform/drivers/simple-framebuffer/* \
	              /sys/bus/platform/drivers/vesa-framebuffer/* \
	              /sys/bus/coreboot/drivers/framebuffer/*; do
		if [ -d "$device" ]; then
			walk_graphics=no
			break
		fi
	done

	# It's possible that a generic framebuffer device works, but is taken
	# over by a more capable driver and no longer available in /sys. We
	# have no reliable consistent way to detect that, so apply heuristics.
	case "$(uname -m)" in
		i386|i686|x86_64) walk_graphics=no ;;
	esac

	if [ -d "/sys/firmware/efi/efivars" ]; then
		walk_graphics=no
	fi

	for node in /sys/firmware/devicetree/base/chosen/framebuffer@*; do
		if [ -d "$node" ] && grep -qz '^simple-framebuffer$' "$node/compatible"; then
			if [ ! -f "$node/status" ] || grep -qz '^\(okay\|ok\)$' "$node/status"; then
				walk_graphics=no
			fi
		fi
	done

	if [ "$walk_graphics" = "yes" ]; then
		class_add_modules backlight
		class_add_modules graphics
	fi

	# catch old-style IDE
	if [ -e /sys/bus/ide/devices/ ]; then
		modules="$modules ide-gd_mod ide-cd"
	fi

	if [ -e /sys/bus/scsi/devices/ ]; then
		modules="$modules sd_mod"
	fi

	if [ -e /sys/bus/mmc/devices/ ]; then
		modules="$modules mmc_block"
	fi

	if [ -e /sys/bus/virtio ] ; then
		modules="$modules virtio_pci virtio_mmio"
	fi

	if [ -e /sys/bus/ps3_system_bus/ ]; then
		modules="$modules ps3disk ps3rom ps3-gelic ps3_sys_manager"
	fi

	if [ -e /sys/bus/vio/ ]; then
		modules="$modules sunvnet sunvdc"
	fi

	for device in /sys/bus/*/drivers/*panel*/*; do
		if [ -d "$device" ] && [ "$(basename "$device")" != "module" ]; then
			sys_walk_mod_add "$device"
		fi
	done

	# shellcheck disable=SC2086
	manual_add_modules $modules
}

# The modules "most" classes added per default to the initramfs
auto_add_modules()
{
	local arg exclude exclude_dir
	local block_modules=
	local modules=

	if [ "$#" -eq 0 ] ; then
		set -- base net ide scsi block ata dasd firewire mmc usb_storage fb
	fi

	local blockfuncs="ahci_platform_get_resources|ata_scsi_ioctl|scsi_add_host|blk_cleanup_queue"
	blockfuncs="${blockfuncs}|register_mtd_blktrans|scsi_esp_register|register_virtio_device"
	blockfuncs="${blockfuncs}|usb_stor_disconnect|mmc_add_host|sdhci_add_host|scsi_add_host_with_dma"
	blockfuncs="${blockfuncs}|blk_mq_alloc_disk|blk_mq_alloc_request|blk_mq_destroy_queue|blk_cleanup_disk"
	blockfuncs="${blockfuncs}|dw_mc_probe|dw_mci_pltfm_register|nvme_init_ctrl"

	for arg in "$@" ; do
		case "$arg" in
		base)
			modules="$modules btrfs ext2 ext3 ext4 f2fs"
			modules="$modules isofs jfs reiserfs squashfs udf xfs"
			modules="$modules nfs nfsv2 nfsv3 nfsv4"
			modules="$modules af_packet atkbd i8042 psmouse"
			modules="$modules virtio_pci virtio_mmio"

			# Include most USB host and dual-role drivers
			copy_modules_dir kernel/drivers/usb/host \
				hwa-hc.ko sl811_cs.ko sl811-hcd.ko \
				u132-hcd.ko whci-hcd.ko
			modules="$modules =drivers/usb/c67x00"
			modules="$modules =drivers/usb/chipidea"
			modules="$modules =drivers/usb/dwc2"
			modules="$modules =drivers/usb/dwc3"
			modules="$modules =drivers/usb/isp1760"
			modules="$modules =drivers/usb/mtu3"
			modules="$modules =drivers/usb/musb"
			modules="$modules =drivers/usb/renesas_usbhs"
			modules="$modules =drivers/usb/typec"
			# Add onboard_usb_hub so it can be probed before
			# mounts, otherwise it might reset power to a
			# USB disk already mounted as root
			modules="$modules onboard_usb_hub onboard_usb_dev"

			# needed for USB on some Qualcomm devices
			modules="$modules =net/qrtr"

			# Include all keyboard drivers and all HID drivers
			# unless we're sure they don't support keyboards.
			# hid-*ff covers various game controllers with
			# force feedback.
			modules="$modules =drivers/input/keyboard"
			copy_modules_dir kernel/drivers/hid \
				'hid-*ff.ko' hid-a4tech.ko hid-cypress.ko \
				hid-dr.ko hid-elecom.ko hid-gyration.ko \
				hid-icade.ko hid-kensington.ko hid-kye.ko \
				hid-lcpower.ko hid-magicmouse.ko hid-ntrig.ko \
				hid-petalynx.ko hid-picolcd.ko hid-pl.ko \
				hid-ps3remote.ko hid-quanta.ko \
				'hid-roccat-ko*.ko' hid-roccat-pyra.ko \
				hid-saitek.ko hid-sensor-hub.ko hid-sony.ko \
				hid-speedlink.ko hid-tivo.ko hid-twinhan.ko \
				hid-uclogic.ko hid-wacom.ko hid-waltop.ko \
				hid-wiimote.ko hid-zydacron.ko
			modules="$modules =drivers/input/serio"
			modules="$modules =drivers/tty/serial"

			# Any of these might be needed by other drivers
			modules="$modules =drivers/bus"
			modules="$modules =drivers/clk"
			modules="$modules =drivers/devfreq"
			modules="$modules =drivers/dma"
			modules="$modules =drivers/extcon"
			modules="$modules =drivers/gpio"
			modules="$modules =drivers/hwspinlock"
			modules="$modules =drivers/interconnect"
			modules="$modules =drivers/i2c/busses"
			modules="$modules =drivers/i2c/muxes"
			modules="$modules =drivers/mailbox"
			modules="$modules =drivers/memory"
			modules="$modules =drivers/mfd"
			modules="$modules =drivers/nvmem"
			modules="$modules =drivers/pci/controller"
			modules="$modules =drivers/phy"
			modules="$modules =drivers/platform/chrome"
			modules="$modules =drivers/power"
			modules="$modules =drivers/pinctrl"
			modules="$modules =drivers/regulator"
			modules="$modules =drivers/reset"
			modules="$modules =drivers/rpmsg"
			modules="$modules =drivers/soc"
			modules="$modules =drivers/spi"
			modules="$modules =drivers/spmi"
			modules="$modules =drivers/usb/phy"
			modules="$modules =drivers/watchdog"

			# Needed for periodic fsck
			modules="$modules =drivers/rtc"
		;;
		net)
			exclude="cdc_mbim|ipheth|qmi_wwan|sierra_net|tun|veth|xen-netback"
			exclude_dir="isdn|net/(802|ethernet|llc|phy|team)|uwb|wan|wireless"
			_call_dracut_install -P "/((${exclude})\.ko|(${exclude_dir})/)" \
				-s "eth_type_trans|register_virtio_device|usbnet_open" \
				"=drivers/net"
			modules="$modules =drivers/net/ethernet =drivers/net/mdio"
			modules="$modules =drivers/net/phy cdc_eem ch9200 ipvlan"
			modules="$modules netconsole r8153_ecm"
		;;
		ide)
			modules="$modules =drivers/ide"
		;;
		mmc)
			modules="$modules =drivers/mmc"
		;;
		scsi)
			_call_dracut_install -s "${blockfuncs}|iscsi_register_transport" \
				"=drivers/message/fusion" "=drivers/s390/scsi" "=drivers/scsi"
			# The following modules are not covered by the symbol filter
			# in the previous call but should be included anyway.
			modules="$modules cxgb3i cxgb4i scsi_dh_alua scsi_dh_emc"
			modules="$modules scsi_dh_rdac scsi_transport_srp"
		;;
		ata)
			block_modules="$block_modules =drivers/ata"
		;;
		block)
			block_modules="$block_modules =drivers/block =drivers/nvme"
			modules="$modules =drivers/ufs"
			modules="$modules vmd"
		;;
		ubi)
			modules="$modules deflate zlib lzo ubi ubifs"
		;;
		firewire)
			modules="$modules firewire-ohci firewire-sbp2"
		;;
		dasd)
			modules="$modules dasd_diag_mod dasd_eckd_mod dasd_fba_mod"
		;;
		usb_storage)
			modules="$modules =drivers/usb/storage"
		;;
		fb)
			# For machines that don't have a generic framebuffer device.
			modules="$modules rockchipdrm pwm-cros-ec pwm_bl pwm-rockchip panel-simple"
			modules="$modules analogix-anx6345 pwm-sun4i sun4i-drm sun8i-mixer panel-edp"
			modules="$modules mediatek-drm pwm-mtk-disp anx7625 parade_ps8640 msm"
			# For panel/backlight on MNT Reform 2
			modules="$modules pwm_imx27 nwl-dsi ti-sn65dsi86 imx-dcss"
			modules="$modules mux-mmio mxsfb"
		;;
		esac
	done

	# shellcheck disable=SC2086
	manual_add_modules $modules
	if [ -n "$block_modules" ]; then
		# shellcheck disable=SC2086
		_call_dracut_install -s "${blockfuncs}" $block_modules
	fi
}

# 'depmod' only looks at symbol dependencies and the 'softdep' module
# information field; there is no way for modules to declare weaker
# dependencies (modules that *might* be needed at run-time) through
# module information, Until this is fixed, we need to handle those
# hidden dependencies.
hidden_dep_add_modules()
{
	# shellcheck disable=SC2046
	_call_dracut_install $(
		{
			cat "${DESTDIR}/lib/modules/${version}/modules.builtin"
			if [ -d "${DESTDIR}/lib/modules/${version}/kernel" ]; then
				find "${DESTDIR}/lib/modules/${version}/kernel" -name '*.ko*'
			fi
		} |
		while read -r module; do
			module="${module##*/}"
			module="${module%%.*}"
			case "$module" in
			libcrc32c)
				echo crc32c
				;;
			ubifs)
				echo deflate zlib lzo
				;;
			btrfs)
				echo crc32c
				;;
			f2fs)
				echo crc32
				;;
			mlx4_core)
				echo mlx4_ib
				;;
			mlx5_core)
				echo mlx5_ib
				;;
			i8042)
				echo psmouse
				;;
			nvme)
				echo vmd
				;;
			spi-rockchip)
				echo pl330
				;;
			dw_mmc-rockchip)
				echo rockchip-io-domain io-domain
				;;
			mediatek-drm)
				echo mediatek-drm-hdmi mtk_iommu mtk-smi
				;;
			mtk_iommu)
				echo mtk-smi
				;;
			phy-mtk-mipi-dsi-drv)
				echo nvmem_mtk-efuse
				;;
			mt6397)
				echo mtk-pmic-wrap
				;;
			qmi_helpers)
				echo qrtr
				;;
			panel-edp)
				# panels don't have devlink to backlight
				echo pwm_bl
				;;
			msm)
				# DP devices which don't have devlinks
				echo pmic_glink_altmode gpio_sbu_mux qrtr
				;;
			esac
		done
		)
}

# Find the source for a script file.  This is needed to work around
# temporary directories mounted with the noexec option.  The source
# will be on / or /usr which must be executable.
get_source()
{
	if [ -z "$scriptdir" ]; then
		echo "${initdir}/$1"
	elif [ -f "${CONFDIR}${scriptdir}/$1" ]; then
		echo "${CONFDIR}${scriptdir}/$1"
	else
		echo "/usr/share/initramfs-tools${scriptdir}/$1"
	fi
}

set_initlist()
{
	unset initlist
	for si_x in "${initdir}"/*; do
		# skip empty dirs without warning
		[ "${si_x}" = "${initdir}/*" ] && return

		# only allow variable name chars
		case "${si_x#"${initdir}"/}" in
		*[![:alnum:]\._-]*)
			[ "${verbose}" = "y" ] \
			&& echo "$si_x ignored: not alphanumeric or '_' file" >&2
			continue
			;;
		esac

		# skip directories
		if [ -d "${si_x}" ]; then
			[ "${verbose}" = "y" ] \
			&& echo "$si_x ignored: a directory" >&2
			continue
		fi

		si_x="$(get_source "${si_x#"${initdir}"/}")"

		# skip non executable scripts
		if [ ! -x "${si_x}" ]; then
			[ "${verbose}" = "y" ] \
			&& echo "$si_x ignored: not executable" >&2
			continue
		fi

		# skip bad syntax
		if ! sh -n "${si_x}" ; then
			[ "${verbose}" = "y" ] \
			&& echo "$si_x ignored: bad syntax" >&2
			continue
		fi

		initlist="${initlist:-} ${si_x##*/}"
	done
}

get_prereq_pairs()
{
	set_initlist
	for gp_x in ${initlist:-}; do
		echo "${gp_x} ${gp_x}"
		gp_src="$(get_source "$gp_x")"
		prereqs=$("${gp_src}" prereqs)
		for prereq in ${prereqs}; do
			echo "${prereq} ${gp_x}"
		done
	done
}

# cache boot scripts order
cache_run_scripts()
{
	DESTDIR=${1}
	scriptdir=${2}
	initdir=${DESTDIR}${scriptdir}
	[ ! -d "${initdir}" ] && return

	true > "${initdir}/ORDER"
	runlist=$(get_prereq_pairs | tsort)
	for crs_x in ${runlist}; do
		[ -f "${initdir}/${crs_x}" ] || continue
		echo "${scriptdir}/${crs_x} \"\$@\"" >> "${initdir}/ORDER"
		echo "[ -e /conf/param.conf ] && . /conf/param.conf" >> "${initdir}/ORDER"
	done
}

call_scripts()
{
	set -e
	for cs_x in ${runlist}; do
		[ -f "${initdir}/${cs_x}" ] || continue
		# mkinitramfs verbose output
		if [ "${verbose}" = "y" ]; then
			echo "Calling hook ${cs_x}"
		fi
		"${initdir}/${cs_x}" && ec=$? || ec=$?
		# allow hooks to abort build:
		if [ "$ec" -ne 0 ]; then
			echo "E: ${initdir}/${cs_x} failed with return $ec." >&2
			# only errexit on mkinitramfs
			[ -n "${version}" ] && exit "$ec"
		fi
		# allow boot scripts to modify exported boot parameters
		if [ -e /conf/param.conf ]; then
			. /conf/param.conf
		fi
	done
	set +e
}

run_scripts()
{
	scriptdir=${2:-}
	initdir=${1}
	[ ! -d "${initdir}" ] && return

	runlist=$(get_prereq_pairs | tsort)
	call_scripts "$scriptdir"
}
